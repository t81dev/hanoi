// t81_mining_testbench.cweb | Multi-Core Aware SHA3 Ternary Mining Test Suite

@* T81 Mining Pipeline Test Suite ‚Äî Multi-Core Aware, Literate Testbench

This test suite targets a **multi-core extension** of `mining_pipeline.v`, allowing parallel SHA3 mining operations on T81 operands.
It integrates:
- ‚úÖ Opcode coverage (NOP, PUSH, POP, ADD)
- üîÅ Nonce iteration engine
- üéöÔ∏è Difficulty threshold configuration
- üßµ Parallel FSM hashing (dual-core model)
- üß™ Verilator + waveform-compatible structure

@c
@<Top-Level Testbench@>

@*1 Top-Level Testbench (Multi-Core Aware)

@<Testbench Harness and Clocking@>
@<Opcode Test Coverage@>
@<Stack and SHA Tracing Signals@>
@<Nonce Logic Extension@>
@<Difficulty Configuration@>
@<Parallel Core Injection (Dual FSM)@>

@*2 Testbench Harness and Clocking

@<Testbench Harness and Clocking@>=
`timescale 1ns/1ps

module tb_mining_pipeline;

    reg clk;
    reg rst;

    reg [7:0] opcode_core0;
    reg [7:0] opcode_core1;
    reg [80:0] operand_core0;
    reg [80:0] operand_core1;
    reg valid_core0;
    reg valid_core1;

    wire match_found_0;
    wire match_found_1;

    mining_pipeline dut0 (
        .clk(clk), .rst(rst),
        .opcode(opcode_core0),
        .operand(operand_core0),
        .start_mine(1'b0),
        .valid_opcode(valid_core0),
        .match_found(match_found_0)
    );

    mining_pipeline dut1 (
        .clk(clk), .rst(rst),
        .opcode(opcode_core1),
        .operand(operand_core1),
        .start_mine(1'b0),
        .valid_opcode(valid_core1),
        .match_found(match_found_1)
    );

    initial clk = 0;
    always #5 clk = ~clk;

    function [80:0] random_t81();
        begin
            random_t81 = {$random, $random, $random} & 81'h1FFFFFFFFFFFFFFFFFFFFFFFF;
        end
    endfunction

    task apply_vector_core0(input [7:0] op, input [80:0] opnd);
        begin
            @(posedge clk);
            opcode_core0 <= op;
            operand_core0 <= opnd;
            valid_core0 <= 1;
            @(posedge clk);
            valid_core0 <= 0;
            @(posedge clk);
        end
    endtask

    task apply_vector_core1(input [7:0] op, input [80:0] opnd);
        begin
            @(posedge clk);
            opcode_core1 <= op;
            operand_core1 <= opnd;
            valid_core1 <= 1;
            @(posedge clk);
            valid_core1 <= 0;
            @(posedge clk);
        end
    endtask

@*2 Opcode Test Coverage

@<Opcode Test Coverage@>=
    initial begin
        $display("=== Multi-Core T81 SHA3 Mining Simulation ===");
        $dumpfile("tb_mining_pipeline.vcd");
        $dumpvars(0, tb_mining_pipeline);

        rst = 1;
        opcode_core0 = 8'h00; operand_core0 = 81'd0; valid_core0 = 0;
        opcode_core1 = 8'h00; operand_core1 = 81'd0; valid_core1 = 0;
        #20; rst = 0; #10;

        $display("[CORE0] PUSH 0x1"); apply_vector_core0(8'h01, 81'h000000000000000000001);
        $display("[CORE1] PUSH 0xA"); apply_vector_core1(8'h01, 81'h00000000000000000000A);

        $display("[CORE0] ADD"); apply_vector_core0(8'h03, 81'd0);
        $display("[CORE1] POP"); apply_vector_core1(8'h02, 81'd0);

        iterate_nonce();
        simulate_parallel_core();

        wait (match_found_0 || match_found_1);
        $display("[SUCCESS] Match found at time %0t!", $time);

        #50;
        $finish;
    end

@*2 Stack and SHA Tracing Signals

@<Stack and SHA Tracing Signals@>=
    // Tracing removed for multi-core clarity; future: add dut0/dut1 trace block

@*2 Nonce Logic Extension

@<Nonce Logic Extension@>=
    task iterate_nonce;
        integer i;
        reg [80:0] base_nonce;
        begin
            base_nonce = 81'h000000000000000000050;
            for (i = 0; i < 16; i = i + 1) begin
                apply_vector_core0(8'h01, base_nonce + i);
                apply_vector_core1(8'h01, base_nonce + 100 + i);
                #10;
            end
        end
    endtask

@*2 Difficulty Configuration

@<Difficulty Configuration@>=
    task configure_difficulty;
        begin
            $display("[CONFIG] Simulated difficulty configuration: 0x0000FFFFFFFF...");
            // Placeholder for external control bus or memory-mapped config
        end
    endtask

@*2 Parallel Core Injection (Dual FSM)

@<Parallel Core Injection (Dual FSM)@>=
    task simulate_parallel_core;
        integer j;
        reg [80:0] core0_nonce, core1_nonce;
        begin
            $display("[SIM] Injecting into dual-core pipeline...");
            core0_nonce = 81'h100000000000000000001;
            core1_nonce = 81'h200000000000000000001;
            for (j = 0; j < 8; j = j + 1) begin
                apply_vector_core0(8'h01, core0_nonce + j);
                apply_vector_core1(8'h01, core1_nonce + j);
                #10;
            end
        end
    endtask

endmodule
