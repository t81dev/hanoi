// t81_mining_testbench.cweb | Extended T81 SHA3 Mining Pipeline with Nonce + Difficulty + Parallelism

@* Extended T81 Mining Pipeline Test Suite ‚Äî Literate Testbench with Nonce Control, Difficulty, and Parallelism

This document validates and scales the `mining_pipeline.v` module, a SHA3-driven ternary mining core
for T81 operands, with advanced features:
- ‚úÖ Opcode test coverage (NOP, PUSH, POP, ADD)
- üîÅ Nonce iteration engine
- üéöÔ∏è Difficulty threshold configuration
- üßµ Parallel FSM stack hashing (dual-core mockup)
- üß™ Verilator + waveform-compatible structure

@c
@<Top-Level Testbench@>

@*1 Top-Level Testbench

@<Testbench Harness and Clocking@>
@<Opcode Test Coverage@>
@<Stack and SHA Tracing Signals@>
@<Nonce Logic Extension@>
@<Difficulty Configuration@>
@<Parallel Core Injection@>

@*2 Testbench Harness and Clocking

@<Testbench Harness and Clocking@>=
`timescale 1ns/1ps

module tb_mining_pipeline;

    reg clk;
    reg rst;

    reg [7:0] opcode;
    reg [80:0] operand;
    reg start_mine;
    reg valid_opcode;

    wire match_found;

    mining_pipeline dut (
        .clk(clk),
        .rst(rst),
        .opcode(opcode),
        .operand(operand),
        .start_mine(start_mine),
        .valid_opcode(valid_opcode),
        .match_found(match_found)
    );

    // Clock generation
    initial clk = 0;
    always #5 clk = ~clk;

    // Random T81 generator
    function [80:0] random_t81();
        begin
            random_t81 = {$random, $random, $random} & 81'h1FFFFFFFFFFFFFFFFFFFFFFFF;
        end
    endfunction

    // Opcode dispatcher
    task apply_vector(input [7:0] op, input [80:0] opnd);
        begin
            @(posedge clk);
            opcode <= op;
            operand <= opnd;
            valid_opcode <= 1;
            @(posedge clk);
            valid_opcode <= 0;
            @(posedge clk);
        end
    endtask

@*2 Opcode Test Coverage

@<Opcode Test Coverage@>=
    initial begin
        $display("=== T81 Mining Pipeline Simulation with Verilator Support ===");
        $dumpfile("tb_mining_pipeline.vcd");
        $dumpvars(0, tb_mining_pipeline);
        $dumpvars(1, dut);
        $dumpvars(1, stack_trace_0, stack_trace_1, fsm_result, sha_input, sha_output);

        rst = 1; opcode = 8'h00; operand = 81'd0; start_mine = 0; valid_opcode = 0;
        #20; rst = 0; #10;

        $display("[TEST] NOP");    apply_vector(8'h00, 81'd0);
        $display("[TEST] PUSH 0x1"); apply_vector(8'h01, 81'h000000000000000000001);

        $display("[TEST] PUSH 0x2 and 0x3");
        apply_vector(8'h01, 81'h000000000000000000002);
        apply_vector(8'h01, 81'h000000000000000000003);

        $display("[TEST] ADD");    apply_vector(8'h03, 81'd0);
        $display("[TEST] POP");    apply_vector(8'h02, 81'd0);

        repeat (3) begin
            $display("[TEST] RANDOM PUSH");
            apply_vector(8'h01, random_t81());
        end

        configure_difficulty();

        $display("[INFO] Starting nonce iteration...");
        iterate_nonce();

        simulate_parallel_core();

        $display("[INFO] Waiting for SHA3 match...");
        wait (match_found == 1);
        $display("[SUCCESS] Match found at time %0t!", $time);

        #50;
        $finish;
    end

@*2 Stack and SHA Tracing Signals

@<Stack and SHA Tracing Signals@>=
    wire [80:0] stack_trace_0 = dut.u_fsm.stack[0];
    wire [80:0] stack_trace_1 = dut.u_fsm.stack[1];
    wire [80:0] fsm_result    = dut.u_fsm.result_out;
    wire [511:0] sha_input    = dut.u_preproc.sha_input;
    wire [511:0] sha_output   = dut.u_sha3.hash_out;

@*2 Nonce Logic Extension

@<Nonce Logic Extension@>=
    task iterate_nonce;
        integer i;
        reg [80:0] base_operand;
        begin
            base_operand = 81'h000000000000000000010;
            for (i = 0; i < 32; i = i + 1) begin
                $display("[MINING] Attempt #%0d, Nonce = %0h", i, base_operand + i);
                apply_vector(8'h01, base_operand + i);
                #10;
            end
        end
    endtask

@*2 Difficulty Configuration

@<Difficulty Configuration@>=
    task configure_difficulty;
        begin
            $display("[CONFIG] Setting mining difficulty to threshold mask: 0x0000FFFFFFFF...");
            // Optional: write to DUT via exposed register or external control logic
            // Placeholder for integration with MMIO or parameterized difficulty
        end
    endtask

@*2 Parallel Core Injection

@<Parallel Core Injection@>=
    task simulate_parallel_core;
        integer j;
        reg [80:0] nonce_a, nonce_b;
        begin
            $display("[SIM] Starting dual-stack mining core simulation...");
            nonce_a = 81'h000000000000000000100;
            nonce_b = 81'h000000000000000000200;
            for (j = 0; j < 16; j = j + 1) begin
                apply_vector(8'h01, nonce_a + j);
                apply_vector(8'h01, nonce_b + j);
                #10;
            end
        end
    endtask

endmodule
