@* Grok API Bridge for Axion AI.
This module implements a ZeroMQ-based bridge to connect Grok 3's NLP queries to
Axion AI via the AxionCLI tool. Now includes symbolic query type `coherence` to
invoke AXION_COHERENCE_GEN as a fallback reasoning scaffold.

@s zmq_t int
@s json_t int
@s json_object int

@*1 Dependencies.
@c
#include <zmq.h>
#include <json-c/json.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <signal.h>
#include <unistd.h>
#include "axioncli.h"

@*1 Global State.
@c
static void *context = NULL;
static void *socket = NULL;
static volatile sig_atomic_t running = 1;

@*1 Signal Handler.
@c
static void signal_handler(int sig) {
    running = 0;
    syslog(LOG_INFO, "Grok bridge: Received signal %d, shutting down", sig);
}

@*1 Bridge Initialization.
@c
void *grok_bridge_init(const char *endpoint) {
    context = zmq_ctx_new();
    if (!context) return NULL;
    socket = zmq_socket(context, ZMQ_REP);
    if (!socket || zmq_bind(socket, endpoint) != 0) {
        zmq_ctx_destroy(context);
        return NULL;
    }
    syslog(LOG_INFO, "Grok bridge: Initialized on %s", endpoint);
    return socket;
}

@*1 Process Query.
@c
json_object *grok_bridge_process(void *socket) {
    zmq_msg_t msg;
    json_object *query = NULL;
    json_object *result = json_object_new_object();
    char *query_str = NULL;

    if (zmq_msg_init(&msg) != 0 || zmq_msg_recv(&msg, socket, 0) == -1) return NULL;

    query_str = strndup(zmq_msg_data(&msg), zmq_msg_size(&msg));
    if (!query_str) return NULL;

    query = json_tokener_parse(query_str);
    if (!query) {
        json_object_object_add(result, "error", json_object_new_string("Invalid JSON"));
        free(query_str);
        zmq_msg_close(&msg);
        return result;
    }

    json_object *type_obj, *value_obj;
    const char *type, *value;
    if (!json_object_object_get_ex(query, "type", &type_obj) ||
        !json_object_object_get_ex(query, "value", &value_obj)) {
        json_object_object_add(result, "error", json_object_new_string("Missing type or value"));
        free(query_str);
        zmq_msg_close(&msg);
        json_object_put(query);
        return result;
    }

    type = json_object_get_string(type_obj);
    value = json_object_get_string(value_obj);
    syslog(LOG_INFO, "Grok bridge: Processing query: type=%s, value=%s", type, value);

    if (strcmp(type, "cmd") == 0) {
        json_object *cli_result = axioncli_execute_tisc(value);
        json_object_object_add(result, "result", cli_result);
    } else if (strcmp(type, "viz") == 0) {
        json_object *viz_result = axioncli_visualize();
        json_object_object_add(result, "result", viz_result);
    } else if (strcmp(type, "coherence") == 0) {
        json_object *coh = axioncli_execute_tisc("run AXION_COHERENCE_GEN");
        json_object_object_add(result, "result", coh);
    } else {
        json_object_object_add(result, "error", json_object_new_string("Unsupported query type"));
    }

    free(query_str);
    zmq_msg_close(&msg);
    json_object_put(query);
    return result;
}

@*1 AxionCLI Interface.
@c
json_object *axioncli_execute_tisc(const char *query) {
    json_object *result = json_object_new_object();
    char cmd[256];
    snprintf(cmd, sizeof(cmd), "axionctl %s", query);
    FILE *fp = popen(cmd, "r");
    if (!fp) {
        json_object_object_add(result, "error", json_object_new_string("Failed to execute command"));
        return result;
    }
    char output[1024] = {0};
    fread(output, 1, sizeof(output) - 1, fp);
    pclose(fp);
    json_object_object_add(result, "output", json_object_new_string(output));
    return result;
}

json_object *axioncli_visualize(void) {
    json_object *result = json_object_new_object();
    FILE *fp = popen("axionctl viz --json", "r");
    if (!fp) {
        json_object_object_add(result, "error", json_object_new_string("Failed to retrieve visualization"));
        return result;
    }
    char output[8192] = {0};
    fread(output, 1, sizeof(output) - 1, fp);
    pclose(fp);
    json_object *viz = json_tokener_parse(output);
    if (viz) {
        json_object_object_add(result, "visualization", viz);
    } else {
        json_object_object_add(result, "error", json_object_new_string("Invalid visualization JSON"));
    }
    return result;
}

@*1 Main Loop.
@c
int main() {
    openlog("grok_bridge", LOG_PID, LOG_DAEMON);
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);

    socket = grok_bridge_init("tcp://*:5555");
    if (!socket) return 1;

    while (running) {
        json_object *result = grok_bridge_process(socket);
        if (!result) continue;
        const char *response = json_object_to_json_string_ext(result, JSON_C_TO_STRING_PLAIN);
        if (response) zmq_send(socket, response, strlen(response), 0);
        json_object_put(result);
    }

    syslog(LOG_INFO, "Grok bridge: Shutting down");
    zmq_close(socket);
    zmq_ctx_destroy(context);
    closelog();
    return 0;
}
