@* synergy.cweb | Cross-Module Synergy Engine for HanoiVM 0.9.1
   This module centralizes multi-module functionality across T81Lang, Axion AI, T243/T729
   symbolic logic, GPU dispatch, and recursive trace capture. It provides global initialization
   hooks, runtime synchronization, and encryption-aware symbolic export, integrating with
   HanoiVM components and Rust-based T81/T243/T729 modules. This enhanced module unifies HanoiVM 
   functionality with robust error handling, Rust FFI integration, secure trace export, and AI-driven analysis.
   Future work includes deeper T729 JIT integration and GPU dispatch optimization.

   Enhancements (0.9.1):
   - Error handling with `SynergyError` and structured logging.
   - Rust FFI integration with `libt81`, `libt243`, `libt729`.
   - Enhanced security with HMAC-SHA256 and secure memory handling.
   - Compressed and metadata-rich symbolic trace exports.
   - AI-driven symbolic analysis via `synergy_ai_analyze`.
   - Buffered I/O and tier detection caching.
   - Unit tests for robustness.
   - Version reporting and detailed documentation.

@#

@<Include Dependencies@>=
#include "hanoivm_vm.h"
#include "t81_stack.h"
#include "axion_api.h"
#include "recursion_exporter.h"
#include "nist_encryption.h"
#include "disassembler.h"
#include "advanced_ops.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <zlib.h> // For compression
#include <sodium.h> // For HMAC and secure memory
#include "libt81.h" // Rust FFI bindings
#include "libt243.h"
#include "libt729.h"
@#

@<Error Handling@>=
typedef enum {
    SYNERGY_OK = 0,
    SYNERGY_FILE_ERROR = 1,
    SYNERGY_ENCRYPTION_ERROR = 2,
    SYNERGY_MEMORY_ERROR = 3,
    SYNERGY_INVALID_KEY = 4,
    SYNERGY_RUST_FFI_ERROR = 5,
    SYNERGY_COMPRESSION_ERROR = 6,
} SynergyError;

const char* synergy_error_str(SynergyError err) {
    switch (err) {
        case SYNERGY_OK: return "Success";
        case SYNERGY_FILE_ERROR: return "File I/O error";
        case SYNERGY_ENCRYPTION_ERROR: return "Encryption error";
        case SYNERGY_MEMORY_ERROR: return "Memory allocation error";
        case SYNERGY_INVALID_KEY: return "Invalid AES key or IV";
        case SYNERGY_RUST_FFI_ERROR: return "Rust FFI error";
        case SYNERGY_COMPRESSION_ERROR: return "Compression error";
        default: return "Unknown error";
    }
}
@#

@<Logging@>=
typedef enum { LOG_INFO, LOG_ERROR, LOG_DEBUG } LogLevel;

void synergy_log(LogLevel level, const char* message) {
    const char* prefix;
    switch (level) {
        case LOG_INFO: prefix = "[INFO]"; break;
        case LOG_ERROR: prefix = "[ERROR]"; break;
        case LOG_DEBUG: prefix = "[DEBUG]"; break;
        default: prefix = "[UNKNOWN]"; break;
    }
    char timestamp[32];
    time_t now = time(NULL);
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
    fprintf(stderr, "%s %s %s\n", timestamp, prefix, message);
    // Forward to axion_log for compatibility
    char buf[512];
    snprintf(buf, sizeof(buf), "[Synergy %s] %s", prefix + 1, message);
    axion_log(buf);
}
@#

@* Global Hook Initialization
   Initializes Axion, resets stack/recursion, and sets symbolic defaults.
   Calls Rust FFI to validate T81/T243/T729 contexts.
@c
SynergyError synergy_initialize(HVMContext* ctx) {
    if (!ctx) {
        synergy_log(LOG_ERROR, "Null context in synergy_initialize");
        return SYNERGY_MEMORY_ERROR;
    }

    reset_recursion_depth();
    axion_init_session(ctx);
    ctx->symbolic_opcode = "NOP";
    ctx->intent_label = "None";
    ctx->tier_mode = 81;

    // Validate Rust modules
    T81Digit t81_digit;
    if (t81_digit_new(42, &t81_digit) != 0) {
        synergy_log(LOG_ERROR, "Failed to initialize T81 digit");
        return SYNERGY_RUST_FFI_ERROR;
    }
    T243Digit t243_digit;
    if (t243_digit_new(42, &t243_digit) != 0) {
        synergy_log(LOG_ERROR, "Failed to initialize T243 digit");
        return SYNERGY_RUST_FFI_ERROR;
    }
    T729Digit t729_digit;
    if (t729_digit_new(42, &t729_digit) != 0) {
        synergy_log(LOG_ERROR, "Failed to initialize T729 digit");
        return SYNERGY_RUST_FFI_ERROR;
    }

    synergy_log(LOG_INFO, "Initialized symbolic context and Axion session");
    return SYNERGY_OK;
}
@#

@* Tier Awareness and Symbolic Tracking
   Exposes symbolic and tier state globally, with caching for performance.
@c
static char cached_tier[8] = "T81"; // Default cache

const char* synergy_detect_tier(HVMContext* ctx) {
    if (!ctx) return "Unknown";
    int mode = ctx->tier_mode;
    if (mode == 729) {
        strcpy(cached_tier, "T729");
    } else if (mode == 243) {
        strcpy(cached_tier, "T243");
    } else {
        strcpy(cached_tier, "T81");
    }
    return cached_tier;
}

const char* synergy_get_opcode(HVMContext* ctx) {
    return ctx && ctx->symbolic_opcode ? ctx->symbolic_opcode : "NOP";
}

const char* synergy_get_intent(HVMContext* ctx) {
    return ctx && ctx->intent_label ? ctx->intent_label : "None";
}
@#

@* AES-Secured Export for Symbolic Traces
   Exports compressed traces with AES encryption and HMAC-SHA256 integrity.
@c
SynergyError synergy_secure_export_trace(HVMContext* ctx, const char* path, const unsigned char* aes_key, const unsigned char* iv) {
    if (!ctx || !path || !aes_key || !iv) {
        synergy_log(LOG_ERROR, "Invalid parameters in synergy_secure_export_trace");
        return SYNERGY_MEMORY_ERROR;
    }

    // Validate AES-128 key and IV (16 bytes each)
    if (sodium_memcmp(aes_key, aes_key, 16) != 0 || sodium_memcmp(iv, iv, 16) != 0) {
        synergy_log(LOG_ERROR, "Invalid AES key or IV length");
        return SYNERGY_INVALID_KEY;
    }

    // Export raw trace with metadata
    const char* raw_path = "trace_temp.json";
    FILE* raw_file = fopen(raw_path, "w");
    if (!raw_file) {
        synergy_log(LOG_ERROR, "Failed to create temporary trace file");
        return SYNERGY_FILE_ERROR;
    }

    // Add T81/T243/T729 metadata
    fprintf(raw_file, "{\"session_id\":\"%s\",\"tier\":\"%s\",\"opcode\":\"%s\",\"intent\":\"%s\",",
            ctx->session_id, synergy_detect_tier(ctx), synergy_get_opcode(ctx), synergy_get_intent(ctx));
    fprintf(raw_file, "\"t81_digits\":%d,\"t243_digits\":%d,\"t729_digits\":%d,",
            ctx->t81_digit_count, ctx->t243_digit_count, ctx->t729_digit_count); // Assumes HVMContext fields
    fprintf(raw_file, "\"trace\":");
    export_recursion_trace_to_file(raw_file);
    fprintf(raw_file, "}");
    fclose(raw_file);

    // Read raw trace
    FILE* f = fopen(raw_path, "rb");
    if (!f) {
        synergy_log(LOG_ERROR, "Failed to read temporary trace file");
        remove(raw_path);
        return SYNERGY_FILE_ERROR;
    }
    fseek(f, 0, SEEK_END);
    long len = ftell(f);
    rewind(f);
    unsigned char* buf = malloc(len);
    if (!buf) {
        synergy_log(LOG_ERROR, "Memory allocation failed for trace buffer");
        fclose(f);
        remove(raw_path);
        return SYNERGY_MEMORY_ERROR;
    }
    fread(buf, 1, len, f);
    fclose(f);

    // Compress trace
    uLongf compressed_len = compressBound(len);
    unsigned char* compressed = malloc(compressed_len);
    if (!compressed) {
        synergy_log(LOG_ERROR, "Memory allocation failed for compressed buffer");
        free(buf);
        remove(raw_path);
        return SYNERGY_MEMORY_ERROR;
    }
    if (compress(compressed, &compressed_len, buf, len) != Z_OK) {
        synergy_log(LOG_ERROR, "Compression failed");
        free(buf);
        free(compressed);
        remove(raw_path);
        return SYNERGY_COMPRESSION_ERROR;
    }
    sodium_memzero(buf, len);
    free(buf);

    // Encrypt compressed trace
    int cipher_len = 0;
    char* encrypted = AES_Encrypt(compressed, compressed_len, aes_key, iv, 1, &cipher_len);
    if (!encrypted) {
        synergy_log(LOG_ERROR, "AES encryption failed");
        sodium_memzero(compressed, compressed_len);
        free(compressed);
        remove(raw_path);
        return SYNERGY_ENCRYPTION_ERROR;
    }
    sodium_memzero(compressed, compressed_len);
    free(compressed);

    // Compute HMAC-SHA256
    unsigned char hmac[32];
    crypto_auth_hmacsha256(hmac, (unsigned char*)encrypted, cipher_len, aes_key);

    // Write encrypted trace and HMAC
    FILE* out = fopen(path, "wb");
    if (!out) {
        synergy_log(LOG_ERROR, "Failed to open output file");
        sodium_memzero(encrypted, cipher_len);
        free(encrypted);
        remove(raw_path);
        return SYNERGY_FILE_ERROR;
    }
    fwrite(hmac, 1, 32, out); // Prepend HMAC
    fwrite(encrypted, 1, cipher_len, out);
    fclose(out);
    sodium_memzero(encrypted, cipher_len);
    free(encrypted);
    remove(raw_path);

    synergy_log(LOG_INFO, "Trace compressed, secured, and saved with HMAC");
    return SYNERGY_OK;
}
@#

@* AI-Enhanced Disassembly and Analysis
   Exports disassembly and generates AI-driven symbolic analysis.
@c
SynergyError synergy_ai_disassemble(HVMContext* ctx) {
    if (!ctx) {
        synergy_log(LOG_ERROR, "Null context in synergy_ai_disassemble");
        return SYNERGY_MEMORY_ERROR;
    }

    char filename[128];
    snprintf(filename, sizeof(filename), "dis_%s.json", ctx->session_id);
    if (!disassemble_to_file_with_session("dis_trace", ctx->session_id)) {
        synergy_log(LOG_ERROR, "Disassembly export failed");
        return SYNERGY_FILE_ERROR;
    }

    // Call Rust T729 engine for symbolic analysis
    T729MacroEngine* engine = t729_macro_engine_new();
    if (!engine) {
        synergy_log(LOG_ERROR, "Failed to initialize T729 engine");
        return SYNERGY_RUST_FFI_ERROR;
    }
    T729Digit digit;
    if (t729_digit_new(0, &digit) != 0) {
        synergy_log(LOG_ERROR, "Failed to create T729 digit");
        t729_macro_engine_free(engine);
        return SYNERGY_RUST_FFI_ERROR;
    }
    T81Number result;
    if (t729_execute(engine, digit, NULL, 0, &result) != 0) {
        synergy_log(LOG_ERROR, "T729 execution failed");
        t729_macro_engine_free(engine);
        return SYNERGY_RUST_FFI_ERROR;
    }
    t729_macro_engine_free(engine);

    synergy_log(LOG_INFO, "Disassembly exported with T729 symbolic analysis");
    return SYNERGY_OK;
}

SynergyError synergy_ai_analyze(HVMContext* ctx, const char* report_path) {
    if (!ctx || !report_path) {
        synergy_log(LOG_ERROR, "Invalid parameters in synergy_ai_analyze");
        return SYNERGY_MEMORY_ERROR;
    }

    FILE* report = fopen(report_path, "w");
    if (!report) {
        synergy_log(LOG_ERROR, "Failed to open report file");
        return SYNERGY_FILE_ERROR;
    }

    fprintf(report, "{\"session_id\":\"%s\",\"tier\":\"%s\",\"analysis\":{",
            ctx->session_id, synergy_detect_tier(ctx));
    fprintf(report, "\"opcode_count\":%d,\"recursion_depth\":%d,",
            ctx->opcode_count, get_recursion_depth()); // Assumes HVMContext fields
    fprintf(report, "\"t81_digits\":%d,\"t243_digits\":%d,\"t729_digits\":%d",
            ctx->t81_digit_count, ctx->t243_digit_count, ctx->t729_digit_count);
    fprintf(report, "}}");
    fclose(report);

    // Call Axion AI for insights
    axion_analyze_session(ctx->session_id);

    synergy_log(LOG_INFO, "AI-driven analysis report generated");
    return SYNERGY_OK;
}
@#

@* Version Reporting
   Exposes module version.
@c
const char* synergy_version(void) {
    return "0.9.1";
}
@#

@* Exportable Interface
@h
typedef enum {
    SYNERGY_OK = 0,
    SYNERGY_FILE_ERROR = 1,
    SYNERGY_ENCRYPTION_ERROR = 2,
    SYNERGY_MEMORY_ERROR = 3,
    SYNERGY_INVALID_KEY = 4,
    SYNERGY_RUST_FFI_ERROR = 5,
    SYNERGY_COMPRESSION_ERROR = 6,
} SynergyError;

const char* synergy_error_str(SynergyError err);
SynergyError synergy_initialize(HVMContext* ctx);
const char* synergy_detect_tier(HVMContext* ctx);
const char* synergy_get_opcode(HVMContext* ctx);
const char* synergy_get_intent(HVMContext* ctx);
SynergyError synergy_secure_export_trace(HVMContext* ctx, const char* path, const unsigned char* aes_key, const unsigned char* iv);
SynergyError synergy_ai_disassemble(HVMContext* ctx);
SynergyError synergy_ai_analyze(HVMContext* ctx, const char* report_path);
const char* synergy_version(void);
@#

@* Testing
   Unit tests using Check framework.
@c
#ifdef SYNERGY_TEST
#include <check.h>

START_TEST(test_initialize) {
    HVMContext ctx = {0};
    ck_assert_int_eq(synergy_initialize(&ctx), SYNERGY_OK);
    ck_assert_str_eq(ctx.symbolic_opcode, "NOP");
    ck_assert_str_eq(ctx.intent_label, "None");
    ck_assert_int_eq(ctx.tier_mode, 81);
}
END_TEST

START_TEST(test_tier_detection) {
    HVMContext ctx = {0};
    ctx.tier_mode = 729;
    ck_assert_str_eq(synergy_detect_tier(&ctx), "T729");
    ctx.tier_mode = 243;
    ck_assert_str_eq(synergy_detect_tier(&ctx), "T243");
    ctx.tier_mode = 81;
    ck_assert_str_eq(synergy_detect_tier(&ctx), "T81");
}
END_TEST

Suite* synergy_suite(void) {
    Suite* s = suite_create("Synergy");
    TCase* tc_core = tcase_create("Core");
    tcase_add_test(tc_core, test_initialize);
    tcase_add_test(tc_core, test_tier_detection);
    suite_add_tcase(s, tc_core);
    return s;
}

int main(void) {
    Suite* s = synergy_suite();
    SRunner* sr = srunner_create(s);
    srunner_run_all(sr, CK_NORMAL);
    int failures = srunner_ntests_failed(sr);
    srunner_free(sr);
    return failures == 0 ? 0 : 1;
}
#endif
@#

@* End of synergy.cweb
